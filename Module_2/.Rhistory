BiocManager::install(c("S4Vectors"), type = "source", force = TRUE)
library(Biostrings)
library(Biostrings)
library(BiocVersion)
library(BiocParallel)
library(BiocManager)
library(BiocGenerics)
library(Biobase)
library(Biostrings)
BiocManager::install(c("Biostrings"), type = "source", force = TRUE)
library(limma)
library(S4Vectors)
library(survival, lib.loc = "C:/Program Files/R/R-4.5.2/library")
library(edgeR)
library(DBI)
library(BSgenome.Hsapiens.UCSC.hg19)
library(BSgenome.Scerevisiae.UCSC.sacCer2)
library(BiocIO)
library(edge)
BiocManager::install(c("edge"), force = TRUE)
library(edge)
BiocManager::install(c("annotate"), force = TRUE)
BiocManager::install(c("AnnotationDbi"), force = TRUE)
library(edge)
library(genefilter)
library(IRanges)
library(qvalue)
library(Rhtslib)
detach("package:S4Vectors", unload = TRUE)
library(sva)
library(sva)
library(XVector)
library(edge)
BiocManager::install(c("S4Vectors"), type = "source", force = TRUE)
remove.packages("S4Vectors")
BiocManager::install(c("S4Vectors"), type = "source", force = TRUE)
setwd("D:/Ajay Files/Genomic Data Science Courses/Genomic Data Science/Course 6 - Statistics for Genomic Data Science/Module_2")
con =url("http://bowtie-bio.sourceforge.net/recount/ExpressionSets/montpick_eset.RData")
load(file=con)
close(con)
mp = montpick.eset
pdata=pData(mp)
# Load Libraries
library(devtools)
library(Biobase)
con =url("http://bowtie-bio.sourceforge.net/recount/ExpressionSets/montpick_eset.RData")
load(file=con)
close(con)
mp = montpick.eset
pdata=pData(mp)
edata=as.data.frame(exprs(mp))
fdata = fData(mp)
# 1. B. Load the Montgomery and Pickrell eSet:
con =url("http://bowtie-bio.sourceforge.net/recount/ExpressionSets/montpick_eset.RData")
load(file=con)
close(con)
mp = montpick.eset
ls()
pdata=pData(mp)
edata=as.data.frame(exprs(mp))
fdata = fData(mp)
# Question 1
# 1. A. Load Libraries
library(devtools)
library(Biobase)
# 1. B. Load the Montgomery and Pickrell eSet:
con =url("http://bowtie-bio.sourceforge.net/recount/ExpressionSets/montpick_eset.RData")
load(file=con)
close(con)
mp = montpick.eset
ls()
pdata=pData(mp)
edata=as.data.frame(exprs(mp))
fdata = fData(mp)
# 1. C. No transformations
svd1 = svd(edata)
ori_pca = svd1$d^2/sum(svd1$d^2)
ori_pca[1]
# 1. D. log2 transform
edata_log2 = log2(edata + 1)
svd2 = svd(edata_log2)
log2_pca = svd2$d^2/sum(svd2$d^2)
log2_pca[1]
# 1. E. log2 transform, subtract row means
edata_centered = edata_log2 - rowMeans(edata_log2)
svd3 = svd(edata_centered)
centered_data_pca = svd3$d^2/sum(svd3$d^2)
centered_data_pca[1]
con =url("http://bowtie-bio.sourceforge.net/recount/ExpressionSets/montpick_eset.RData")
load(file=con)
close(con)
mp = montpick.eset
pdata=pData(mp)
edata=as.data.frame(exprs(mp))
fdata = fData(mp)
# 2. B. Log2 Transform and centre data by subtracting row means
edata_log2 = log2(edata + 1)
edata_centered = edata_log2 - rowMeans(edata_log2)
# 2. C. Use SVD to calculate the singular vectors
set.seed(333)
svd1 = svd(edata_centered)
# 2. D. Perform K-means Clustering and correlate 1st SVD and K-means cluster
edata_kmeans = kmeans(t(edata_centered), centers=2)
cor.test(svd1$v[,1], edata_kmeans$cluster)
edata_centered
# 2. B. Log2 Transform and centre data by subtracting row means
edata_log2 = log2(edata + 1)
edata_centered = edata_log2 - rowMeans(edata_log2)
# 2. C. Use SVD to calculate the singular vectors
set.seed(333)
svd1 = svd(edata_centered)
# 2. D. Perform K-means Clustering and correlate 1st SVD and K-means cluster
edata_kmeans = kmeans(t(edata_centered), centers=2)
cor.test(svd1$v[,1], edata_kmeans$cluster)
# 2. D. Perform K-means Clustering and correlate 1st SVD and K-means cluster
edata_kmeans = kmeans(t(edata_centered), centers=2)
svd1$v[,1]
edata_kmeans$cluster
cor.test(svd1$v[,1], edata_kmeans$cluster)
# 2. D. Perform K-means Clustering and correlate 1st SVD and K-means cluster
edata_kmeans = kmeans(t(edata_centered), centers=2)
cor.test(svd1$v[,2], edata_kmeans$cluster)
# 2. D. Perform K-means Clustering and correlate 1st SVD and K-means cluster
edata_kmeans = kmeans(t(edata_centered), centers=2)
cor.test(svd1$v[,3], edata_kmeans$cluster)
# 2. D. Perform K-means Clustering and correlate 1st SVD and K-means cluster
edata_kmeans = kmeans(t(edata_centered), centers=2)
cor.test(svd1$v[,1], edata_kmeans$cluster)
con =url("http://bowtie-bio.sourceforge.net/recount/ExpressionSets/bodymap_eset.RData")
load(file=con)
close(con)
bm = bodymap.eset
edata = exprs(bm)
pdata_bm=pData(bm)
# 3. B. Fit linear model
lm1 = lm(edata[1,] ~ pdata_bm$num.tech.reps)
lm1
# 3. C. Plot the data
plot(pdata_bm$num.tech.reps,edata[1,])
abline(lm1, col=2, lwd=3)
# 5. A.	Load the Montgomery and Pickrell eSet:
con =url("http://bowtie-bio.sourceforge.net/recount/ExpressionSets/montpick_eset.RData")
load(file=con)
close(con)
ls()
mp = montpick.eset
head(mp)
pdata=pData(mp)
head(pdata)
edata=as.data.frame(exprs(mp))
head(edata)
fdata = fData(mp)
head(fdata)
# 5. B. Log2 transform the expression data
edata = log2(edata + 1)
# 5. C. fit a regression model to each sample, using population as the outcome
mod = model.matrix(~ pdata$population)
mod
fit = lm.fit(mod, t(edata))
summary(fit)
fit
summary(fit)
# 5. D. dimension of the residual matrix
dim(fit$residuals)
# 5. E. Dimension of the effects matrix
dim(fit$effects)
# 5. F. Dimension of the coefficients matrix
dim(fit$coefficients)
# 5. C. fit a regression model to each sample, using population as the outcome
mod = model.matrix(~ pdata$population)
head(mod)
fit = lm.fit(mod, t(edata))
summary(fit)
# 5. D. dimension of the residual matrix
dim(fit$residuals)
# 5. E. Dimension of the effects matrix
dim(fit$effects)
# 5. F. Dimension of the coefficients matrix
dim(fit$coefficients)
fit$coefficients
summary(fit$coefficients)
# 7. A.	Load the Bodymap data with the following command
con =url("http://bowtie-bio.sourceforge.net/recount/ExpressionSets/bodymap_eset.RData")
load(file=con)
close(con)
ls()
bm = bodymap.eset
head(bm)
edata = exprs(bm)
head(edata)
pdata_bm=pData(bm)
head(pdata_bm)
# 7. B. Load Libraries
library(devtools)
library(Biobase)
library(limma)
library(edge)
# 7. C. Subset the expression data to the samples without missing values of age
pdata_bm = na.omit(pdata_bm)
edata = edata[,rownames(pdata_bm), drop=FALSE]
head(edata)
# 7. D. Fit many regression models to the expression data where age is the outcome
mod_adj = model.matrix(~ pdata_bm$age)
mod_adj
fit_limma = lmFit(edata,mod_adj)
fit_limma$coefficients[1000,]
edata
fit_limma$coefficients[1000,]
fit_limma$coefficients[2000,]
dim(fit_limma$coefficients)
fit_limma$coefficients[3000,]
fit_limma$coefficients[5000,]
# 7. E. make a plot of the 1,000th gene and fitted values
intercept = fit_limma$coefficients[1000,][1]
slope = fit_limma$coefficients[1000,][2]
x = edata[1000,]*slope+intercept
plot(x,pdata_bm$age)
# 7. E. make a plot of the 1,000th gene and fitted values
intercept = fit_limma$coefficients[1000,][1]
slope = fit_limma$coefficients[1000,][2]
x = edata[1000,]*slope+intercept
plot(x,pdata_bm$age)
abline(fit_limma[1000,], col=2, lwd=3)
# 9. A. Multicollinearity between the population and study variables
head(pdata)
head(pdata)
cor.test(as.numeric(as.factor(pdata$population)), as.numeric(as.factor(pdata$study)))
pop = as.numeric(as.factor(pdata$population))
pop
pop = as.numeric(as.factor(pdata$population))
pop
study = as.numeric(as.factor(pdata$study))
study
head(pdata)
pop = as.numeric(as.factor(pdata$population))
pop
study = as.numeric(as.factor(pdata$study))
study
cor.test(pop, study)
con =url("http://bowtie-bio.sourceforge.net/recount/ExpressionSets/bodymap_eset.RData")
load(file=con)
close(con)
ls()
bm = bodymap.eset
head(bm)
edata = exprs(bm)
head(edata)
pdata_bm=pData(bm)
head(pdata)
